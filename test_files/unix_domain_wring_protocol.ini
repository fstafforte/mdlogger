[GLOBAL]
enabled = true # if this ky is missing mdlogger does not start !!!

# Missing pattern key means pattern = [%{timestamp:utc} %{msg_type}] %{message}
# Valid pattern placeholder
# %{timestamp:utc}  log message utc time timestamp
# %{timestamp:loc}  log message utc time timestamp
# %{msg_type}       log message type
# %{appname}        application name
# %{appversion}     application version
# %{thread}         thread name or thread id if name has not been set where the log has been made
# %{category}       log message category
# %{file}           file name where the log has been made
# %{function}       function name where the log has been make
# %{line}           source line number where the log has been made
# %{message}        user message 
pattern = [<%{timestamp:utc} | %{timestamp:loc}> %{msg_type}, %{appname}, %{appvarsion}, %{thread}, %{category}, %{file}, %{function}, %{line}] %{message}

# timestamp format [use rust crate time format see https://time-rs.github.io/book/api/format-description.html]
# if timestamp_format is empty pr missing the default '[year]-[month]-[day] [hour]:[minute]:[second].[subsecond digits:3] [offset_hour sign:mandatory]:[offset_second]' is used
# due to the use of '[' & ']" fotmat has to be sorround by '"'
timestamp_format = "[year]-[month]-[day] [hour]:[minute]:[second].[subsecond digits:3] [offset_hour sign:mandatory]:[offset_second]"

# missing log message type enabling key by default has a false value execpt for fatal 
debug.enabled = true
info.enabled = true
warning.enabled = true
critical.enabled = true
# fatal log types can not be disabled

# missing or empty log message type key has the fallowing values:
# debug.text = Debug
# info.text = Info
# warning.text = Warning
# critical.text = Critical
# fatal.text = Fatal

debug.text = D
info.text = I
warning.text = W
critical.text = C
fatal.text = F

# root log handler can not be empty initialization error occurs
root_log_handler = UNIX_DOMAIN_UDP

# if external commands ip address are missing or wrong
# a warning messag is printed-out an no commands will be managed
# ip address could be unicast or multicast (IPV4 or IPV6) and you can specify
# on wich interface multicast using external_command.multicast_if
# i.g external_command.multicast_if = 192.168.207.128
# otherwise multicast message will be received on all network
# interfaces
external_command.ipaddress = 192.168.207.128
external_command.port = 54321



[UNIX_DOMAIN_UDP]
type = unix-domain
enabled = true # missing eanbled key means enabled = false
log_message_format = json_pretty # valid message format are (plain_text, json, json_pretty)
# GLOBAL message type enabling flags could be overwritten
# i.g.
# debug.enabled = false
# info.enabled = false

# GLOBAL message pattern could be overwritten
# i.g.
# pattern = <%{timestamp:utc} %{msg_type}, %{thread}, %{category}> %{message}

# valid protocols are: udptcp (NOTE: case insensitive), it cannot be missed or empty
protocol = mcast
# sun_path can contains environment variable (espressed in unix style ${<varname>}) or an absolute path
# which size cannot be greater than 108 bytes
sun_path = ${TMP}/local_server
# in case remote address is a multicast address and you want specify wich local interface use
# to send multicast value set multicast_if otherwise the system choose
# according to the routing table
# udp has no need of this key 'multicast_if'

